
    /**
     * move to a target
     * @param {PIXI.DisplayObject} object - object to animate
     * @param {PIXI.DisplayObject|PIXI.Point} target (should have a .x and .y parameter)
     * @param {number} speed - number of pixels to move per millisecond
     * @param {object=} options
     * @param {object=} options.wait - wait n milliseconds before starting animation (can also be used to pause animation for a length of time)
     * @param {Renderer=} renderer - sets Renderer.dirty for each loop
     * @param {boolean=} pause - pause animation indefinitely
     * @param {boolean=} keepAlive - don't cancel the animation when target is reached
     * @param {Function=} onDone - callback for when the animation expires or is cancelled
     *                             is also triggered when keepAlive = true and the target is reached (triggers on each update)
     * @param {Function=} onFirst - callback for first time update is called (does not include pause or wait time)
     * @param {Function=} onEach - callback after each update
     * @param {Function=} onWait - callback for wait loops
     * @param {Function} ease - easing function from easing.js (see http://easings.net for examples)
     */
    target(object, target, speed, options)
    {
        return this.add(new Target(object, target, speed, options));
    }

    /**
     * face (spin to) a target
     * @param {PIXI.DisplayObject} object to spin
     * @param {PIXI.DisplayObject|PIXI.Point} target to face
     * @param {number} speed - number of radians to move per millisecond
     * @param {object} [options]
     * @param {number} [options.wait] n milliseconds before starting animation (can also be used to pause animation for a length of time)
     * @param {Renderer} [options.renderer] sets Renderer.dirty for each loop
     * @param {boolean} [options.pause] start the animation paused
     * @param {boolean} [options.keepAlive] don't cancel the animation when target is reached
     * @param {Function} [options.onDone] function pointer for when the animation expires
     * @param {Function} [options.onFirst] function pointer for first time update is called (does not include pause or wait time)
     * @param {Function} [options.onWait] function pointer for wait
     * @param {Function} [options.onEach] function pointer called after each update
     */
    face(object, target, speed, options)
    {
        return this.add(new Face(object, target, speed, options));
    }

    /**
     * animate a list of PIXI.Textures
     * @param {PIXI.Sprite} object to animate
     * @param {PIXI.Texture[]} textures to cycle
     * @param {number} duration
     * @param {object} [options] (same as Animate.to)
     * @param {Function} [ease] easing function
     */
    movie(object, textures, duration, options, ease)
    {
        function each(elapsed)
        {
            var index = Math.floor(dummy.count);
            for (var i = 0; i < list.length; i++)
            {
                list[i].texture = textures[index];
            }
            if (onEach)
            {
                onEach(elapsed, object);
            }
        }

        var list = (Array.isArray(object)) ? object : [object];
        var dummy = {count: 0};
        var onEach = options.onEach;
        options.onEach = each;
        return new To(dummy, {count: textures.length - 1}, duration, options, ease);
    }

    /**
     * move at an angle
     * {PIXI.DisplayObject} object - object to animate
     * {number} angle - angle to move at
     * {number} speed - number of pixels to move per millisecond
     * {number=} duration - milliseconds to move (leave empty or set to 0 for unlimited duration)
     * {object} options
     * {number=} options.wait in milliseconds before starting animation (can also be used to pause animation for a length of time)
     * {Renderer=} renderer - sets renderer.dirty = true for each loop
     * {Function=} onDone - callback for when the animation expires or is cancelled
     * {Function=} onFirst - callback for first time update is called (does not include pause or wait time)
     * {Function=} onEach - callback called after each update
     * {Function=} onWait - callback for wait
     */
    angle (object, angle, speed, duration, options)
    {
        return this.add(new Angle(object, angle, speed, duration, options));
    }
